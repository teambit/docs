---
id: add-components
title: Add Components
---

import { Image } from '../../src/components/image';

A Bit component is an independent module that can be authored, maintained, shared and consumed **independently**.
It has all the information it needs to enable such autonomy. That includes its packaged distributable code, development files, history, documentation and various Bit configurations.
Most of that information is generated automatically by Bit.

This section will start our components' journey to independency by tracking them using Bit.

:::note what do we mean by "components"?
The word “component” is ascribable to any independent feature, whether it is a simple UI primitive, a piece of logic, a data-connected component, or even a full page.
:::

## Add components

Our project has 4 components:

- 1 React hook
- 2 UI elements
- 1 Widget

Each component in a Bit workspace must have all its implementation files under the same directory.
Moreover, a component must have an entry file (`index.[ts|js]` is used as the default. Learn how to configure a different file, here).

Track the React hook with the namespace 'hooks':

```shell
bit add components/hooks/use-jokes/ --namespace hooks
```

The `use-jokes` component is now tracked by Bit and managed by the workspace.

Two things have happened that are worth noticing:

#### Files to components

Bit has mapped this component's files and registered them in the `.bitmap` file. This enables Bit to treat a collection of files as a single unit, a component.

In addition to that, Bit has generated a component ID, with the pattern
`<namespaces>/<component-name>`. The component ID will be prefixed with the scope name once a it has been exported to a remote scope (`<owner>.<scope>/<namespaces>/<component-name>`).

Head over to your workspace `.bitmap` file, to see the generated mapping.

```
{
    "hooks/use-jokes": {
        "scope": "",
        "version": "",
        "mainFile": "index.ts",
        "rootDir": "components/hooks/use-jokes"
    }
}
```

#### Components to packages

Bit has generated a package for that component in the workspace `node_modules` directory. That includes compiling the source-code using the [development environment compiler](/compiling/overview).
The **package name** will be `@demo-org/demo-scope.hooks.use-jokes`, following the pattern `@<owner>/<scope>.<namespaces>.<component-name>`.

:::note
Components using other components in the same workspace should only use the components' absolute paths, i.e, their package names.
This is done to enable components to be context-agnostic.
:::

Track the UI elements with the namespace 'ui/elements'. Use the `*` wildcard to select all folders under 'ui-elements'

```shell
bit add components/ui/elements/* --namespace ui/elements
```

Here, too, both components will have their component IDs and packages generated by Bit.

### Resolve an issue found in a component

Go back to the Workspace UI (https://localhost:3000) to see the newly tracked components.

Our 'button' component is marked with a `1, N` to its right to signify that it is a new component that has 1 issue that needs to be resolved.

![](/img/issue_found.png)

To understand what this issue is, let's check our workspace status:

```shell
bit status
```

```shell {7,8}
new components
(use "bit tag --all [version]" to lock a version with all your changes)

     > hooks/use-jokes ... ok
     > ui-elements/app-bar ... ok
     > ui-elements/button ...  issues found
       missing packages dependencies (make sure you've added it to the package dependencies, and use `bit install` to make sure all package dependencies are installed):
          button.spec.tsx -> @testing-library/react
```

The above output informs us that `@testing-library/react`, required by our component's test file, is missing.

### Install dependencies

We'll install `@testing-library/react` using [Dependency Resolver](/dependencies/overview), a Bit extension that handles dependencies in a workspace.

```shell
bit install @testing-library/react
```

The installed package is now added to our workspace dependency configuration:

```json title="workspace.jsonc"
  "teambit.dependencies/dependency-resolver": {
    "packageManager": "teambit.dependencies/pnpm",
    "policy": {
      "dependencies": {
        "@testing-library/react": "11.2.5"
      },
      "peerDependencies": {}
    }
  }
```

:::note
Our package is listed under `dependencies` even though it is a dev dependency. Dependency Resolver searches for the files requiring each package.
If all these files are dev files (test files, etc.) then a dependency will be considered as a dev dependency even though it is not listed as such. Learn more about it [here](/dependencies/dependency-policies).
:::

### Add a component that is dependant on other components

Our project has one component left to be tracked: 'tech-jokes-viewer'.

Our 'tech-jokes-viewer' is dependent on 2 other components: 'button' and 'use-jokes'.
As mentioned before, each of these tracked components has its code compiled by Bit and placed in its own package directory, inside the workspace `node_modules` directory.

Before we track 'tech-jokes-viewer', let's change its import paths from `org-demo` to your own username or organization name:

```tsx
// REPLACE 'demo-org' WITH YOUR OWN ORGANIZATION/USERNAME
import { Button } from '@demo-org/demo-scope.ui.elements.button';
import { useJokes } from '@demo-org/demo-scope.hooks.use-jokes';
```

:::note Use a valid scope
Import paths must consist of valid username/organization and scope name.
These should be identical to the values set in the `defaultScope` property, in the `workspace.jsonc`.
:::

Once the above modification is done, add the component with the namespace 'ui/widgets':

```shell
bit add components/ui/widgets/tech-jokes-viewer/ --namespace ui/widgets
```

Head back to the Workspace UI (https://localhost:3000) to explore the tracked components.

<Image src="/img/ws_getting_started_1.png" padding={10} />
